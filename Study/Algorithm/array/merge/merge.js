// 병합 정렬 : 일단 반으로 나누고 나중에 합치는 방식

// 병합 정렬 특징: 병합 정렬은 배열의 요소를 합치는 순간에 정렬을 한다.

// 병합 정렬 시간 복잡도 O(N*logN)

let = 8;
var sort = [8]; // 병합 정렬은 반드시 전역 변수로 선언 해줘야 한다.
// 정렬을 수행할 때 기존의 배열 뿐만 아니라 추가적인 배열이 필요하다.
// 그래서 전역 변수가 아닌 것을 사용하면 추가적인 배열을 필요 할 때마다 추가로 생성을 하기 때문에 메모리 효율상 비효율 적이다.
// 그래서 전역 변수로 선언을 하게 되면 추가적인 배열은 전역으로 사용을 하기 때문에 비효율적 메모리를 효율성있게 사용할 수 있는 것이다.

// 병합 정렬은 배열이 3가지가 필요하다. 부분집합용 2개와 부분집합을 합칠 1개 해서 총 3개의 배열이 필요하다.
// 그래서 코드상의 개념으로 시작점, 중간점, 끝점을 개념을 잡고 접근을 하면, 부분집합 2개를 합치는 개념과 같다.

let a = [];

const MergeSort = (a, m, middle, n) => {
  let i = m; // 시작점   [6,7]
  let j = middle + 1; // 중간점  7] [5  : 메모리 구조상 배열이 붙어 있음
  var k = m; // 끝점   [5,8]

  while (i <= middle && j <= n) {
    // i <= middle && j <= n
    // 시작점은 미들까지
    // 부분집합 각 2개중 각 부분집합에 제일 작은 값이 먼저 k에 들어간다.
    if (a[i] <= a[j]) {
      // a의 i가 a의 j에 위치한(index) 값이 작다면
      sort[k] = a[i];
      // 부분집합들의 집합이 될 집합 k에  a[i]값을 집어 넣는다.
      i++;
      // 부분집합의 집합체 배열 k의 요소들을 이동시키는 의미
    } else {
      sort[k] = a[j];
      // 만약 그렇지 않다면 // 부분집합들의 집합이 될 집합 k에  a[j]값을 집어 넣는다.
      j++;
      // 부분집합의 집합체 배열 k의 요소들을 이동시키는 의미
    }
    k++; // 정렬이 되고 있는 부분집합 요소 나머지 데이터들을 정렬 시키는 과정
    if (i > middle) {
      // 만약에 부분집합 요소 i가 middle 값 보다 클 때 실행
      // 이때는 i가 속한 부분집합 요소들이 모두 정렬이 된 상태
      for (let t = j; t <= n; t++) {
        sortged[k] = a[t];
        //남은 j 값을 넣어준다.
        k++;
        // 부분집합의 집합체 배열 k의 요소들을 이동시키는 의미
      }
    } else {
      // 이때는 j가 속한 부분집합 요소들이 모두 정렬이 된 상태
      for (let t = i; t < middle; t++) {
        sort[k] = a[t];
        //남은 i 값을 넣어준다.
        k++;
        // 부분집합의 집합체 배열 k의 요소들을 이동시키는 의미
      }
    }

    // 정렬된 부분집합을 집합체에 삽입하는 과정
    for (let t = m; t <= n; t++) {
      // 부분집합의 모든 위치[index]를 방문 하면서
      a[t] = sort[t];
      // 정렬된 배열의 값을 실제 배열에 값으로 이동하는 과정
    }
  }
};

const MergeSortRe = (a, m, middle, n) => {
  // 반을 나누고 하는 개념의 병합 정렬
  // 크기가 1보다 큰 경우만 사용
  if (m < n) {
    middle = (m + n) / 2;
    // 정중앙을 가르키는 용도
    MergeSortRe(a, m, middle);
    // 중앙을 기점으로 왼쪽으로 병합을 수행
    MergeSortRe(a, middle + 1, n);
    // 중앙을 기점으로 오른쪽으로 병합을 수행
    MergeSort(a, m, middle, n);
    // 부분집합들의 집합체
  }
};

let arr = [1, 5, 7, 8, 11, 3, 4, 9];

MergeSort(arr, 0, [...arr] - 1);
for (let i = 0; i < [...arr]; i++) {
  console.log("병합 정렬:", arr[i]);
}

// 병합 정렬 작동 순서

// 배열과 배열 요소들 : [5,1,3,4,2,7,6,9,8]

// 0. 배열의 요소가 각각의 인덱스를 가지고 있음

// 1. 배열의 인덱스 0,1 / 2,3, / 4,5 / 6,7 .. 이런식으로  2의 배수만 큼 합친다. 합치며 정렬

// 2. 배열의 인덱스 0,1,2,3, / 4,5,6,7 .. 이런식으로 합친다. 이때 합쳐질 때 낮은 숫자가 왼쪽으로 오름차순 or 내림차순 정렬이 된다. 합치며 정렬

// 3. 배열의 인덱스 0,1,2,3,4,5,6,7 .. 위 2번과 같은 방식으로 진행으로  합쳐질 때 낮은 숫자가 왼쪽으로 오름차순 or 내림차순 정렬이 되고 종료한다. 합치며 정렬

// 병합 정렬 시간 복잡도 O(N*logN)인 이유

// [5,1,3,4,2,7,6,9,8] 의 너비(가로)는 N 으로 2개의 부분집합에서 1개의 정렬된 집합을 만드는 것은 N밖에 소모가 안된다.
// N^2가 아닌 N인 이유는 병합 정렬은  이미 정렬이 되있는 것을 합치기 때문이다.
// i, j는 부분집합 k는 i와j를 합칠 집합으로 현재는 빈공간을 가진 index가 있다고 가정을 하면
// i, j 부분집합 배열은 이미 정렬이 되었다고 판별을 하고 k 배열에 합치게 된다.
// 이때 합치는 과정에서 i와 j에서 배열의 요소 크기를 비교하여 k를 순차적으로 합치게 된다. 이때 총 4번의 비교연산을 하게 된다.
// 그래서 N만큼 소요가 되는 것이다.

// 높이(세로)는 logN

// 높이는 3 밖에 안된다. 병합 정렬 순서가 실제로 작동 하는 건 1~3으로 끝나기 때문

// 그래서 병합 정렬의 시간 복잡도는 N * logN = O(N*logN)이고, 같은 시간 복잡도를 가진 퀵정렬의 한계점을 효과적으로 보안을 해준다.
// 하지만 평균적으로 놓고 보았을 때는 퀵정렬 보다는 빠르지는 않다.
