// 라빈 카프(Rabin-Karp) 알고리즘

// 라빈 카프 알고리즘은 특이한 문자열 매칭 알고리즘이다. 항상 빠르지는 않지만 일반적인 경우 빠르게 작동하는 간단한 구조의 문자열 매칭 알고리즘이라는 점에서 자주 사용하는 알고리즘이다.
// 라빈 카프 알고리즘은 해시(Hash) 기법을 사용한다. 해시는 일반적으로 긴 데이터가 있다면, 그것을 상징하는 짧은 데이터로 바꾸어주는 기법이다.
// 상징하는 데이터로 바꾸어 처리한다는 점에서 단순 해시 알고리즘의 경우 연산 속도는 O(1)에 달한다는 엄청난 장점이 있다.

// 해시(Hash)만 해도 굉장히 많은 숫자의 알고리즘이 있을 뿐만 아니라 각기 다르게 구현될 수 있다.
// 하지만 문자열 매칭은 연속적인 문자열이 이어지는 경우에 기반하기 때문에 해시 또한 연속적인 경우에 더 빠르게 구할 수 있는 알고리즘을 채택하여 적용하면 더 매우 빠르게 연산할 수 있다.

// 예) 문자열 abacaaba의 해시 값
// 97 * 2^7 : a = 97 (16진수 변환 값)
// 98 * 2^6 : b = 98
// 97 * 2^5 : a = 97
// 99 * 2^4 : c = 99
// 97 * 2^3 : a = 97
// 97 * 2^2 : a = 97
// 98 * 2^1 : b = 98
// 97 * 2^0 : a = 97
// 해시 값 = 24,833

// 위 상황은 각 문자의 아스키 코드 값에 2의 제곱 수를 차례대로 곱하여 더해준 것
// 이러한 방식을 이용하면 서로 다른 문자열의 경우 일반적으로 해시 값이 다르게 나온다.

// 문자열 abacaaba과 abacaabb의 해시 값을 구하고 비교해보면

// 예) 문자열 abacaabb의 해시 값
// 97 * 2^7 : a = 97 (16진수 변환 값)
// 98 * 2^6 : b = 98
// 97 * 2^5 : a = 97
// 99 * 2^4 : c = 99
// 97 * 2^3 : a = 97
// 97 * 2^2 : a = 97
// 98 * 2^1 : b = 98
// 98 * 2^0 : b = 98
// 해시 값 = 24,833

// 위와 같이 문자열이 달라지면 최종 결과로 출력되는 해시 값도 바뀌는 걸 알 수 있다.
// 물론 해시 값이 중복되는 경우도 발생할 수 있다. 이러한 상황을 충돌(Collision)이라고 한다.
// 보통 발생할 확률이 높지 않기 때문에 무시하고 넘어간다.

// 즉 라빈 카프 알고리즘은 여러 개의 문자열을 비교할 때 항상 해시 값을 구하여 비교하고, 해시 값은 거의 일치하는 일이 없기 때문에
// '긴 글'과 '부분 문자열'의 해시 값이 일치하는 경우에만 문자열을 재검사하여 정확히 일치하는지 확인하는 알고리즘이다.

// 예) 긴글 : ababacabacaabacaaba, 부분 문자열: abacaaba

// "1회 동작"
// 긴글긴글긴 : a | b | a | b | a | c | a | b | a | c | a | a | b | a | c | a | a | b | a |
// 찾을문자열 : a | b | a | c | a | a | b | a | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

// 긴글 문자열 abacaaba 해시 값
// 97 * 2^7 : a = 97 (16진수 변환 값)
// 98 * 2^6 : b = 98
// 97 * 2^5 : a = 97
// 98 * 2^4 : b = 98
// 97 * 2^3 : a = 97
// 99 * 2^2 : c = 99
// 97 * 2^1 : a = 97
// 98 * 2^0 : b = 98
// 해시 값 = 24824

// 부분 문자열 abacaaba 해시 값
// 97 * 2^7 : a = 97 (16진수 변환 값)
// 98 * 2^6 : b = 98
// 97 * 2^5 : a = 97
// 99 * 2^4 : c = 99
// 97 * 2^3 : a = 97
// 97 * 2^2 : a = 97
// 98 * 2^1 : b = 98
// 97 * 2^0 : a = 97
// 해시 값 = 24833

// 긴글 해시 :24824  ≠ 부분 해시 :24833

// 위와 같은 방식으로 작동을 하며 긴글 해시와 부분 문자열 해시 값이 일치하지 않으면
// 다음으로 넘어간다.

// "2회 동작"
// 긴글긴글긴 : 0 | b | a | b | a | c | a | b | a | c | a | a | b | a | c | a | a | b | a |
// 찾을문자열 : a | b | a | c | a | a | b | a | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

// 위와 같이 긴글 배열이 한칸 오른쪽으로 밀리면서 b부터 기준점을 잡고 찾을 문자열과 검색을 한다.
// 이런 방식으로 긴글 해시는 부분 문자열 해시와 값이 같을 때까지 계속 한칸 한칸 오른쪽으로 이동을 하며 기준점을 잡는다.

// "3회 동작"
// 긴글긴글긴 : 0 | 0 | a | b | a | c | a | b | a | c | a | a | b | a | c | a | a | b | a |
// 찾을문자열 : a | b | a | c | a | a | b | a | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

// "4회 동작"
// 긴글긴글긴 : 0 | 0 | 0 | b | a | c | a | b | a | c | a | a | b | a | c | a | a | b | a |
// 찾을문자열 : a | b | a | c | a | a | b | a | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

//     .
//     .
//     .

// "7회 동작"
// 긴글긴글긴 : 0 | 0 | 0 | 0 | 0 | 0 | a | b | a | c | a | a | b | a | c | a | a | b | a |
// 찾을문자열 : a | b | a | c | a | a | b | a | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

// 긴글의 기준점이 오른쪽으로 7번 이동을 했을 때 긴글과 부분문자열이 매칭이 되는 상황이다.
// 이때 긴글 문자열과 부분 문자열의 해시 값이 같아진다.

// 긴글 문자열 abacaaba 해시 값
// 97 * 2^7 : a = 97 (16진수 변환 값)
// 98 * 2^6 : b = 98
// 97 * 2^5 : a = 97
// 99 * 2^4 : c = 99
// 97 * 2^3 : a = 97
// 97 * 2^2 : a = 97
// 98 * 2^1 : b = 98
// 97 * 2^0 : a = 97
// 해시 값 = 24833

// 부분 문자열 abacaaba 해시 값
// 97 * 2^7 : a = 97 (16진수 변환 값)
// 98 * 2^6 : b = 98
// 97 * 2^5 : a = 97
// 99 * 2^4 : c = 99
// 97 * 2^3 : a = 97
// 97 * 2^2 : a = 97
// 98 * 2^1 : b = 98
// 97 * 2^0 : a = 97
// 해시 값 = 24833

// 긴글 해시 :24833 = 부분 해시 :24833

// 위와 같이 7번째 문자에서 매칭이 됐음을 발견하고 매칭 된 값을 출력을 하고 종료를 하게 된다.
// 그래서 이러한 라빈 카프 알고리즘은 O(N)의 시간 복잡도를 가지게 된다.
// 이렇게 빠르게 계산할 수 있는 이유는 긴 글 해시를 구하는 연속적인 과정이 연결된 수학적 수식에 의해 반복되기 때문이다.

// 긴 글 해시 값 = 2 * (긴 글 해시 값 - 가장 앞에 있는 문자의 수치) + 새롭게 들어온 문자의 수치로
// 위와 같은 공식을 사용하면 앞에서부터 뒤로 쭉 읽으면서 값을 구할 수 있어 매우 빠르다고 할 수 있는 것이다.
