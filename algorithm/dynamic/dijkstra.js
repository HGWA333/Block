// 다익스트라(Dijkstra) 알고리즘

// 다익스트라 알고리즘은 다이나믹 프로그래밍을 활용한 대표적인 최단 경로(Shortest Path) 탐색 알고리즘이다.
// 흔히 인공위성 GPS 소프트웨어 등에서 가장 많이 사용된다. 다익스트라 알고리즘은 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려준다.
// 이 때 음의 간선을 포함할 수 없다. 현실 세계에서도 음의 간선이 존재하지 않기 때문에 다익스트라는 현실 세계에 사용하기 매우 적합한 알고리즘 중 하나다.

// 다익스트라 알고리즘이 다이나믹 프로그래밍 문제인 이유는 '최단 거리는 여러 개의 최단 거리로 이루어져있기 때문'
// 작은 문제가 큰 문제의 부분 집합에 속해 있다고 볼 수 있음.
// 기본적으로 다익스트라는 하나의 최단 거리를 구할 때 이전까지 구했던 최단 거리 정보를 그대로 사용한다는 특징이 있다.

// 다익스트라 알고리즘은 상황에 따라 다이나믹 프로그래밍으로 분류가 되기도 하고, 그리드 알고리즘이라고 분류가 되기도 한다.
// 그 이유는 최단 거리는 여러 개의 최단 거리로 이루어져있기 때문이다.

// A -> B ,  B -> C ,  C -> D 가는 경로가 A -> D로 가는 경로가 최단 거리라고 가정을 하면,
// A -> B , A -> C 로 가는 경로 또한 최단 경로가 되어야 한다.
// 즉 작은 문제가 큰 문제의 부분 집합에 속해있는 형태이다.
// 그래서 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다는 특징이 있다.
// 또 다익스트라 알고리즘은 정렬을 사용하기 때문에 정렬 이후에 가장 적은 것을 하나씩 선택 하는 것이 알고리즘에 포함이 되어있다.
// 이런 이유 때문에 그리즈 알고리즘이라고 분류가 되기도 한다.

// 다익스트라 알고리즘 작동방식

// 노드의 갯수 4개
// 예) [1, 2, 3, 4]

// 간선의 갯수 5개
// 1) 1 -> 2  비용: 3
// 2) 1 -> 3  비용: 6
// 3) 1 -> 4  비용: 7
// 4) 2 -> 3  비용: 1
// 5) 3 -> 4  비용: 1

// 노드 1은 2, 3, 4를 지나가는 간선 3개가 존재한다.
// 당장 눈에 보이는 간선 비용 3, 6, 7을 기록 한다.

// 이때 노드 1에서 3으로 바로 가는 비용은 6이다.
// 하지만 이때 노드 2를 기준을 잡고 2에서 1을 방문하고 2에서 3을 방문했을 때 비용은 3+1 총 4의 비용이 발생한다.
// 그래서 1에서 3으로 가는 비용보다 1에서 2를 방문하고 2에서 3으로 방문하는 비용이 저렴하다는 것을 알 수 있다.
// 이 때 현재까지 알고 있던 3으로 가는 최소 비용인 6을 새롭게 4로 갱신을 한다.
// 이런 방식으로 돌아가는 것으로 현재까지 기존에 알고 있던 최단 경로를 계속 갱신한다.

// 다익스트라 알고리즘 구체적인 작동방식
// 1. 출발 노드를 설정
// 2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장
// 3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택
// 4. 해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하고 최소 비용을 갱신함.
// 5. 1 ~ 4 과정을 3~4번 반복한다.

// 노드의 갯수 4개
// 예) [1, 2, 3, 4, 5, 6]

// 간선의 갯수 10개
// 1) 1 -> 2  비용: 2
// 2) 1 -> 3  비용: 5
// 3) 1 -> 4  비용: 1
// 4) 2 -> 3  비용: 3
// 5) 2 -> 4  비용: 2
// 6) 4 -> 3  비용: 3
// 7) 4 -> 5  비용: 1
// 8) 5 -> 3  비용: 1
// 9) 5 -> 6  비용: 2
// 10) 6 -> 3  비용: 5

// 노드 1)  1 - 1    1 - 2    1 - 3    1 - 4    1 - 5    1 - 6
//            0        2        5        1      무한      무한

// 노드 2)  2 - 1    2 - 2    2 - 3    2 - 4    2 - 5    2 - 6
//            2        0        3        2      무한      무한

// 노드 3)  3 - 1    3 - 2    3 - 3    3 - 4    3 - 5    3 - 6
//            5        3        0        3        1        5

// 노드 4)  4 - 1    4 - 2    4 - 3    4 - 4    4 - 5    4 - 6
//            1        2        3        0        1      무한

// 노드 5)  5 - 1    5 - 2    5 - 3    5 - 4    5 - 5    5 - 6
//          무한      무한      1        1        0        2

// 노드 6)  6 - 1    6 - 2    6 - 3    6 - 4    6 - 5    6 - 6
//          무한      무한      5       무한       2        0

// 다익스트라 (Dijkstra) 알고리즘 코드화
// 각 노드를 거쳐가는 상황
// 노드 1 = {0, 2, 5, 1, INF, INF}
// 노드 2 = {2, 0, 3, 2, INF, INF}
// 노드 3 = {5, 3, 0, 3, 1, 5}
// 노드 4 = {1, 2, 3, 9, 1, INF}
// 노드 5 = {INF, INF, 1, 1, 0, 2}
// 노드 6= {INF, INF, 5, INF, 2, 0}

// 전체 그래프를 초기화 하는 과정
let INF = 1000000;
let dij = [
  [0, 2, 5, 1, INF, INF],
  [2, 0, 3, 2, INF, INF],
  [5, 3, 0, 3, 1, 5],
  [1, 2, 3, 9, 1, INF],
  [INF, INF, 1, 1, 0, 2],
  [INF, INF, 5, INF, 2, 0],
];

let dijArr = [0, 1, 2, 3, 4, 5];
let boolArr = Array.isArray(dijArr);
console.log(Array.isArray(dijArr));
console.log(Array.isArray(boolArr));
console.log(boolArr);

function getSmallIndex() {
  let min = INF;
  let index = 0;
  for (let i = 0; i < number; i++) {
    if (d[i] < min && !v[i]) {
      min = d[i];
      index = i;
    }
  }
  return index;
}

function dijkstar(_start) {
  // 다익스트라를 작동하는 함수
  for (let i = 0; i < number; i++) {
    d[i] = a[_start][i];
  }
  v[_start] = true;
  for (let i = 0; i < number - 2; i++) {
    let current = getSmallIndex();
    v[current] = true;
    for (let j = 0; j < 6; j++) {
      if (!v[j]) {
        if (d[current] + a[current][j] < d[j]) {
          d[j] = d[current] + a[current][j];
        }
      }
    }
  }
}

function dijExport() {
  dijkstar(0);
  for (let i = 0; i < number; i++) {
    console.log("dijkstar", d[i]);
  }
}
