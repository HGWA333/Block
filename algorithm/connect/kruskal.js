// 크루스칼 알고리즘

// 크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘이다.
// 최소 비용 신장 트리를 만들기 위한 대표적인 알고리즘으로 예를 들면
// 여러 개의 도시가 있을 때 각 도시를 도로를 이용해 연결하고자 할 때 비용을 최소한으로 해결하고자 할 떄 실제로 적용되는 알고리즘

// 용어 개념 정리

// 노드 = 정점 = (도시) : 그래프에서 노드에 해당 하는 부분
// 간선 = 거리 = (비용) : 그래프에서 선에 해당하는 부분

// 예를 들어 노드의 갯수 7개 그리고 간선의 갯수 11개인 그래프가 있다고 가정을 한다.

// 노드의 갯수 7개
// [1, 7, 4, 2, 5, 3, 6 ]

// 간선의 갯수 11개
// 1) 1 -> 5  비용: 17
// 2) 1 -> 7  비용: 12
// 3) 7 -> 4  비용: 13
// 4) 4 -> 1  비용: 28
// 5) 7 -> 5  비용: 73
// 6) 1 -> 2  비용: 67
// 7) 2 -> 5  비용: 62
// 8) 2 -> 4  비용: 24
// 9) 5 -> 6  비용: 45
// 10) 5 -> 3  비용: 20
// 11) 6 -> 3  비용: 37

// 각 노드에 간선을 연결하여 최소 비용 신장 트리를 산출
// 간선 숫자 = 노드 숫자 - 1  =  6
// 모든 노드에 연결 될 간선 수는 6개만 있으면 된다.

// 간선을 거리가 짧은 순서대로 그래프에 포함시키는 것이 핵심으로
// 여기서 중요한 것은 각 노드들이 사이클(순환구조)를 형성 시키면 안된다는 것이다.
// 그래서 모든 거리(비용)을 기준으로 먼저 오름차순 정렬로 수행을 하고 다음의 알고리즘에 맞게 그래프를 연결하면
// 가장 적은 비용으로 모든 노드를 연결한 그래프인 '최소 비용 신장 트리'가 완성이 된다.

// 최소 비용 신장 트리 순서
// 1. 정렬된 순서에 맞게 그래프에 포함시킨다.
// 2. 포함시키기 전에 사이클 테이블을 확인한다.
// 3. 사이클을 형성하는 경우 간선을 포함하지 않는다.

// 최단 거리 간선 노드 연결

// 예) 1 - 7
//      12
// 1과 7이 연결 되었는데 비용은 12이다.

// 노드 1)  1 - 7    1 - 4    1 - 2    1 - 5
//           12       28       67       17

// 노드 2)  2 - 4    2 - 5
//           24       62

// 노드 3)  3 - 5    3 - 6
//           20       37

// 노드 4)  4 - 7
//           13

// 노드 5)  5 - 6    5 - 7
//           45       73

// 최단 거리 간선 노드 경로

// 7 -> 1 (비용:12) -> 4 (비용:13) -> 1 -> 5 (비용:17) -> 3 (비용:20)-> 4 -> 2 (비용:24) -> 3 -> 6 (비용:37) 종료

// 7 -> 1 -> 4 -> 1 -> 5-> 3 -> 4 -> 2 -> 3 -> 6 -> 종료
// 총 비용: 12 + 13 + 17 + 20 + 24 + 37

// 여기서 4 -> 2 이후 다음에 연결 될 최소비용 경로로 간다면 4는 1로 가야한다. 하지만 4 -> 1 로 가게 된다면 여기서 4, 7, 1은 순환구조 형태가 완성이 된다. 그래서  3 -> 6의 경로를 가고 종료를 하게 된다.
// 사이클이 발생하는지의 여부는 Union-Find 알고리즘을 그대로 적용하면 된다.
// 단순히 연결이 된 이후에는 Union(합침)을 해주면 되고 사이클이 발생하는지는 Find(찾기)를 해주면 된다.

// 크루스칼 알고리즘 작동 방식

// 초기 상태

// 노드 비용 낮은 값 오름차순)
// 노드 )  1 - 7    4 - 7    1 - 5    3 - 5   2 - 4   1 - 4   3 - 6   5 - 6   2 - 5   1 - 2   5 - 7
//          12       13       17       20      24      28      37      45      62      67      73

// < 사이클 테이블 >
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7]
// 두 번째 행  [1, 2, 3, 4, 5, 6, 7]

// < 첫 번째 작동 사이클 테이블 >
// 7 -> 1 (비용:12)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7]
// 두 번째 행  [1, 2, 3, 4, 5, 6, 1]

// < 두 번째 작동 사이클 테이블 >
// 7 -> 4 (비용:13)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7]
// 두 번째 행  [1, 2, 3, 1, 5, 6, 1]

// < 세 번째 작동 사이클 테이블 >
// 1 -> 5 (비용:17)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7]
// 두 번째 행  [1, 2, 3, 1, 1, 6, 1]

// < 네 번째 작동 사이클 테이블 >
// 5 -> 3 (비용:20)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7]
// 두 번째 행  [1, 2, 1, 1, 1, 6, 1]

// < 다섯 번째 작동 사이클 테이블 >
// 4 -> 2 (비용:24)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7]
// 두 번째 행  [1, 1, 1, 1, 1, 6, 1]

// < 여섯 번째 작동 사이클 테이블 > - 완성 -
// 여기서 1 -> 4(비용: 28)을 연결 하면 순환구조 상태가 되기 때문에 1 -> 4 간선은 무시하고 넘어간다.
// 3 -> 6 (비용:37)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7]
// 두 번째 행  [1, 1, 1, 1, 1, 1, 1]

// 나머지 간선들
//  5 - 6   2 - 5   1 - 2   5 - 7
//   45      62      67      73
// 최소 비용 신장 트리가 완성이 되어 이후 남은 간선은 무시하고 넘어간다.

function getParent(parent, x) {
  // 부모 노드를 찾는 함수
  let parent = [];
  let x;
  if (parent[x] == x) return x;
  return (parent[x] = getParent(parent, parent[x]));
}

function unionParent(parent, a, b) {
  // 두 부모 노드를 합치는 함수
  let parent = [];
  a = getParent(parent, a);
  b = getParent(parent, b);
  if (a < b) parent[b] = a;
  else parent[a] = b;
}

function findParent(parent, a, b) {
  // 같은 부모를 가지는지 확인 하는 함수
  a = getParent(parent, a);
  b = getParent(parent, b);
  if (a == b) return 1;
  return 0;
}

// 함수 getParent, unionParent, findParent 이 3가지가 있으면 사이클이 발생하는지 확인할 수 있다.

class Edge {
  // 최소 신장 트리 비용
  // 간선 정보를 담는 클래스를 만든다.
  node = [2];
  distance;
  constructor(a, b, distance) {
    let a = this.node[0];
    let b = this.node[1];
    let distance = distance;
  }
  operator(Edge, edge) {
    return this.distance < edge.distance;
  }
}

function Kru() {
  let n = 7;
  let m = 11;
  let v = [];
  v.push(Edge(1, 7, 12));
  //  v.push(Edge(1, 7, 12)) = 1,7은 간선, 12은 비용
  v.push(Edge(1, 5, 17));
  v.push(Edge(2, 4, 24));
  v.push(Edge(2, 5, 62));
  v.push(Edge(3, 5, 20));
  v.push(Edge(3, 6, 37));
  v.push(Edge(4, 7, 13));
  v.push(Edge(5, 6, 45));
  v.push(Edge(5, 7, 73));

  sort(v.begin(), v.end());
  // sort(v.begin(), v.end())는  간선의 비용을 기준으로 호름차순 정렬

  let parent = [n];
  // 각 정점이 포함된 그래프가 어디인지 parent에 저장
  for (let i = 0; i < n; i++) {
    parent[i] = i;
  }

  let sum = 0;
  // 사이클이 발생하지 않는 경우 그래프에 포함시킨다.
  for (let i = 0; i < v.size(); i++) {
    if (!findParent(parent, v[i].node[0] - 1, v[i].node[1] - 1)) {
      sum += v[i].distance;
      // 해당 간선 거리만큼 결과 값에 더해준다.
      unionParent(parent, v[i].node[0] - 1, v[i].node[i] - 1);
      // 실제 두개의 노드를 연결 해준다.
    }
  }
}
