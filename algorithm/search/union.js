// 합집합 찾기(Union-Find)

// 합집합 찾기 알고리즘은 대표적인 그래프 알고리즘이다.
// 서로소 집합(disjoint-Set) 알고리즘이라고 부르기도 한다.
// 구체적으로 여러 개의 노드가 존재 하고 있을 떄 두개의 노드를 선택해서,
// 현재 선택 된 이 두 노드가 서로 같은 그래프에 속하는지 판별을 하는 알고리즘이다.

// 합집합 찾기 알고리즘의 원리는 강한 결합 요소(Strongly Connected Component) SCC로 고급알고리즘에도 적용이 된다.

// 합집합 찾기 작동 방식
// 여러 개의 노드가 서로 자유분방하게 존재하고 있는 상황에서 각 노드들은 서로 연결이 되지 않고,
// 각자 자기 자신만을 집합의 원소로 가지고 있을 때 다음과 같이 표현할 수 있다.
// 바로 모든 값이 자기 자신을 가르키도록 만드는 것이다.

// 예)
// 첫 번째 행 = 노드 번호
// 두 번째 행 = 부모 노드 번호
// 표현은 배열로 표현 한다.

// 초기 상태)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7, 8]
// 두 번째 행  [1, 2, 3, 4, 5, 6, 7, 8]

// 1과 2가 연결 된 상태)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7, 8]
// 두 번째 행  [1, 1, 3, 4, 5, 6, 7, 8]
// 바로 위와 같이 2번째 인덱스 값에 1이 들어간다.
// 이렇게 부모 노드를 합칠 때는 일반적으로 더 작은 값 쪽으로 합친다.
// 바로 이것을 합침(Union)이라고 한다.

// 2와 3이 연결 된 상태)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7, 8]
// 두 번째 행  [1, 1, 2, 4, 5, 6, 7, 8]
// 바로 위와 같이 3번째 인덱스 값에 2가 들어간다.
// 여기서 의문점은 바로 1과 3이 "어떻게 연결되었는지 파악을 할 수 있냐" 이다.
// 1과 3은 부모가 각각 1과 2로 다르기 때문에 "부모 노드"만 보고서는 한번에 파악할 수가 없다.
// 그렇게 때문에 재귀 함수를 사용하여 해결을 한다.
// 3의 부모를 찾기 위해서는 먼저 3이 가르키고 있는 2를 찾아야 한다.
// 그렇게 되면 2의 부모가 1을 가르키고 있다는 것을 알 수 있다. 이러한 과정은 재귀적으로 수행될 때 가장 효과적이고
// 직관적으로 언어를 사용할 수있다. 그래서 합침(Union) 연산이 다 수행이 되면 다음과 같은 상태가 된다.

// 합침(Union)이 완료 된 상태)
// 첫 번째 행  [1, 2, 3, 4, 5, 6, 7, 8]
// 두 번째 행  [1, 1, 1, 4, 5, 6, 7, 8]
// 3은 2를 가르키고 있다.
// 2는 1을 가르키고 있다.
// 1은 1 자기 자신을 가르키고 있다.
// 이렇게 되면 3의 최종적인 부모는 1이라는 것을 알 수 있다.
// 따라서 3의 두 번째 행의 인덱스에 1의 값으로 갱신을 할 수 있는 것이다.
// 첫 번째 행의 노드 1, 2, 3의 부모는 모두 1이다. 때문에 이 세 가지 노드는 모두 같은 그래프에 속한다고 할 수 있다.
// Find 알고리즘은 두 개의 노드 중 부모 노드를 확인하여 현재 같은 집합에 속하는지 확인하는 알고리즘이다.

const parent = [];

const getParent = (parent, x) => {
  // getParent는 특정한 노드의 부모를 찾는 용도 함수로 부모 노드를 찾는 함수이다.
  if (parent[x] == x) return x;
  // 만약에 매개변수로 들어온 x의 값이 해당 부모와 값이 같으면 x 자체를 리턴
  return (parent[x] = getParent(parent, parent[x]));
  // 만약에 매개변수로 들어온 x의 값이 해당 부모와 값이 같지 않으면
  // 부모를 찾기 위해 재귀적 함수를 실행
};

function UnionParent(parent, a, b) {
  // 두 부모 노드를 합치는 함수

  a = getParent(parent, a);
  b = getParent(parent, b);
  // 각각의 부모 값을 구한다.

  if (a < b) parent[b] = a;
  // 부모 a 값보다 b가 더 크다면 부모 a의 값을 b에 넣어준다.
  // 더 작은 값 쪽으로 부모를 합친다. 두 번째 행이 바뀌는 형태
  else parent[a] = b;
  // 만약 그렇지 않고 b보다 a가 더 크다면 a의 값에 부모b의 값을 넣어준다.
}

function FindParent(parent, a, b) {
  // 같은 부모를 가지고 있는지 확인하는 용도의 함수

  a = getParent(parent, a);
  b = getParent(parent, b);
  if (a == b) return 1;
  // 만약 부모 a와 부모 b가 같다면 1의 값을 리턴한다.
  return0;
  // 만약 그렇지 않다면 0의 값을 반환한다.
}
