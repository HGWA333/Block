// 너비 우선 탐색(Breath First Search) : 탐색을 할 때 너비(가로)를 우선으로 탐색을 수행하는 탐색 알고리즘
// 맹목적으로 무엇이든 따지지 않고 탐색을 하고자 할 때 사용할 수 있는 탐색 기법으로 너비 우선 탐색은 최단 경로를 찾아준다는 점으로
// 최단 길이를 보장해야 할 때 사용한다. 주로 미로찾기 알고리즘에서 많이 사용이 된다.

// BFS는 너비를 우선으로 하여 탐색한다는 특성이 중요하다.
// 이것은 BFS를 이용하여 다른 알고리즘에 적용하여 효과적으로 사용한다는 것이 핵심

// 너비 우선 탐색 순서

// 0. 너비 우선 탐색시 배열의 데이터들은 이미 정렬이 되어있는 상태여야 한다.

// 1. BFS는 가장 처음 시작 노드 (Start Node)를 큐에 삽입을 하고 시작을 한다. 그리고 큐에 삽입된 노드는 저장이 된다.
// (만약 시작 노드를 방문 했다면, 방문한 곳은 처리 방문 했다고 처리를 해준다.)

// 2. 큐에 저장된 노드 하나를 꺼낸다.

// 3. 해당 노드에 연결된 노드 중 방문을 하지 않은 노드를 방문하며 차례대로 큐에 삽입을 한다.

// 4. 1 ~ 3 순서를 반복

// 예)   1
//    2  -  3
//   4-5   6-7

// ===== 너비 우선 탐색 동작 방식 순서 =====

// 첫 번째
// ----------
//  1          <- 큐에 저장 된 1을 꺼낸다.
// ----------
// ----------
//  2,3        <- 1 방문 처리 후 큐에 저장
// ----------
// 1이 방문할 수 있는 곳은 2,3

// 두 번째
// ----------
//  1, 2       <- 큐에 저장 된 2를 꺼낸다.
// ----------
// ----------
//  3, 4, 5    <- 2 방문 처리 후 큐에 저장
// ----------
// 2가 방문할 수 있는 곳은 3,4,5

// 세 번째
// ----------
//  1, 2 ,3   <- 큐에 저장 된 3을 꺼낸다.
// ----------
// ----------
//  6, 7      <- 3 방문 처리 후 큐에 저장
// ----------
// 3가 방문할 수 있는 곳은 6, 7

// 세 번째까지 진행이 되면 큐에 저장이 된 것은

// ---------------------
//  1, 2, 3, 4, 5, 6, 7   <- 큐에 최종적으로 저장됨
// ---------------------

// 큐에서 꺼낸 순서는 1, 2, 3, 4, 5, 6, 7이다.

// 가장 맨 밑에 있는 노드들을 가장 늦게 방문하기 때문에

const number = 7;
const BFS_Arr = [1, 2, 3, 4, 5, 6, 7];
const TempArr = [1, 2, 3, 4, 5, 6, 7, 8];

const BFS = () => {
  queue = q;
  q.push(start);
  c[start] = true;
  while (!q.empty()) {
    // que안의 데이터가 빈 공간이 될 때까지 돌리는 용도
    let x = q.front();
    // que 1개를 꺼내여 x에 담는다.
    q.pop();
    console.log("que:", x);
    for (let i = 0; i < a[x].size(); i++) {
      // 현재 que에서 꺼낸 것의 위치를 기준으로 가장 인접한 곳을 방문 하면서
      let y = a[x][i];
      if (!c[y]) {
        // 현재 방문을 한 상태라면 무시를 한다. if(!c[y]) 조건문을 실행 하지 않는다.
        // 현재 방문을 한 상태가 아니라면
        q.push(y);
        // que에 담아준다.
        c[y] = true;
        // c[y] = true는 방문 처리를 했다는 의미
      }
    }
  }
};

const BFS_Test = () => {
  a[1].push_back(2);
  a[2].push_back(1);
  // 1과 2를 연결
  a[1].push_back(3);
  a[3].push_back(1);
  // 1과 3을 연결
  a[2].push_back(3);
  a[3].push_back(2);
  // 2와 3을 연결
  a[2].push_back(4);
  a[4].push_back(2);
  // 2와 4를 연결
  a[2].push_back(5);
  a[5].push_back(2);
  // 2와 5를 연결
  a[3].push_back(3);
  a[6].push_back(6);
  // 3과 6을 연결
  a[3].push_back(3);
  a[7].push_back(7);
  // 3과 7을 연결
  a[6].push_back(7);
  a[7].push_back(6);
  // 6과 7을 연결

  BFS_Test(1);
  return 0;
};
