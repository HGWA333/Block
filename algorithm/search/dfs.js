// 깊이 우선 탐색(Depth First Search) : 탐색하는 대상은 보다 깊은 것을 우선적으로 하여 탐색하는 알고리즘이다.
// 이런 깊이 우선 탐색은 맹목적(무엇이든 따지지 않고)으로 각 노드를 탐색할 때 주로 사용된다.
// 만약 너비 우선 탐색에서 큐(Queue)가 사용이 되었다면, 깊이 우선 탐색에서는 스택(Stack)이 사용된다.
// 더불어 스택을 사용하지 않아고 재귀함수로도 구현이 가능한 특징을 가지고 있는데
// 그 이유는 컴퓨터는 구조적으로 항상 스택의 원리를 사용하기 때문이다.

// DFS는 DFS 자체로는 큰 의미가 없다. DFS를 활용해서 문제를 해결하고자 하는 것에 포커싱을 하면 된다.
// 또한 스택을 직접 사용하지 않고 재귀 함수를 이용하여 간략한 함수를 구현할 수 있다는 것이 핵심으로
// 다양한 그래프 알고리즘을 구현할 때 많이 사용한다.

// 깊이 우선 탐색 순서

// 0. 깊이 우선 탐색시 배열의 데이터들은 이미 정렬이 되어있는 상태여야 한다.

// 1. 스택의 최상단 노드를 확인한다.

// 2. 최상단 노드에게 방문하지 않은 인접 노드가 있다면, 그 노드를 스택에 넣고 방문처리한다.
// 방문 하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 뺀다.

// 예)   1
//    2  -  3
//   4-5   6-7

// ===== 깊은 우선 탐색 동작 방식 순서 =====

// 첫 번째
// ----------
//  1          <- 스택에 저장 된 1을 꺼낸다.
// ----------
// ----------
//  1, 2        <- 1 방문 처리 후 스택에 저장
// ----------
// 1이 방문한 곳은 2

// 두 번째
// ----------
//  1, 2       <- 스택에 저장 된 2를 꺼낸다.
// ----------
// ----------
//  1, 2, 3    <- 2 방문 처리 후 스택에 저장
// ----------
// 2가 방문한 곳은 3

// 세 번째
// ----------
//  1, 2 ,3         <- 스택에 저장 된 3을 꺼낸다.
// ----------
// --------------
//  1, 2, 3, 6      <- 3 방문 처리 후 스택에 저장
// --------------
// 3이 방문한 곳은 6

// 네 번째
// --------------
//  1, 2 ,3, 6       <- 스택에 저장 된 3을 꺼낸다.
// --------------
// --------------
//  1, 2, 3, 6, 7    <- 3 방문 처리 후 스택에 저장
// --------------
// 6이 방문한 곳은 7

// ---------- 네번째 이후  인접한 노드가 없어 스택에 나오는 상황 ---------

// 다섯 번째
// ----------
//  1, 2          <- 스택에 저장 된 3을 꺼낸다.
// ----------
// ----------
//  1, 2, 4       <- 3 방문 처리 후 스택에 저장
// ----------
// 2가 방문한 곳은 4

// 여섯 번째
// ----------
//  1, 2, 4        <- 스택에 저장 된 3을 꺼낸다.
// ----------
// -------------
//  1, 2, 4, 5     <- 3 방문 처리 후 스택에 저장
// -------------
// 4가 방문한 곳은 5

// 일곱 번째
// -----------
//  1, 2, 4, 5    <- 모든 곳을 방문
// -----------
// -----------
//    Void        <- 모든 곳을 방문 후 스택이 비워짐
// -----------

// 일곱 번째까지 진행이 되면 깊은 우선 탐색이 방문한 경로는

// --------------------------
//  1 - 2 - 3 - 6 - 7 - 4 - 5  <- 깊은 우선 탐색으로 방문한 경로
// --------------------------

const number = 7;
const DFS_Arr = [1, 2, 3, 4, 5, 6, 7];
const TempArr = [1, 2, 3, 4, 5, 6, 7, 8];

const DFS = (_x) => {
  // 매개변수 _x가 들어 왔을 때
  if (c[_x]) return;
  // 해당 노드를 방문 했다면 아무 값 없이 바로 리턴하여 함수를 끝낸다.
  c[_x] = true;
  // 만약 처음 방문을 했다면 방문 처리를 해준다.

  (count << _x) << "";
  // 해당 노드를 출력 해주는 의미

  for (let i = 0; i < a[_x].size(); i++) {
    // 해당 노드와 바로 붙어있는 모든 인접 노드들을 하나씩
    let y = a[_x][i];
    DFS(y);
    // 인접 노드를 대상으로 DFS(깊은 우선 탐색)을 수행한다.
    // 재귀 함수 사용
  }
};

const DFS_Test = () => {
  a[1].push_back(2);
  a[2].push_back(1);
  // 1과 2를 연결
  a[1].push_back(3);
  a[3].push_back(1);
  // 1과 3을 연결
  a[2].push_back(3);
  a[3].push_back(2);
  // 2와 3을 연결
  a[2].push_back(4);
  a[4].push_back(2);
  // 2와 4를 연결
  a[2].push_back(5);
  a[5].push_back(2);
  // 2와 5를 연결
  a[3].push_back(3);
  a[6].push_back(6);
  // 3과 6을 연결
  a[3].push_back(3);
  a[7].push_back(7);
  // 3과 7을 연결
  a[6].push_back(7);
  a[7].push_back(6);
  // 6과 7을 연결

  BFS_Test(1);
  return 0;
};
