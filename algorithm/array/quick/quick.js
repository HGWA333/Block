// 퀵 정렬 = 분할 정복 알고리즘을 사용하며 알고리즘 평균 속도가 O(N * log^N)이다.

// 특징 = 하나의 배열이 있을 때 그 배열을 반복적으로 분할을 하는 특징을 가지고 있다. 원소를 두 집합으로 나누고 기준 값이 있다.
// 기준 값을 피벗(Pivot)이라고 한다.

// 예) [6, 10, 5, 3, 8, 9, 4, 2, 1] => 배열의 첫 번째 원소 6을 기준 값으로 설정

// 퀵 정렬 시간 복잡도 = O(N * log^N)

// 퀵 정렬 순서

// 1. 6보다 큰 수를 왼쪽에서 오른쪽을 탐색한다. 6보다 큰 수는 바로 옆 10이 있기 때문에 10을 선택 이때 10이 첫 번째 원소
// 2. 6보다 작은 수를 선택 6보다 작은 수는 오른쪽에서 왼쪽으로 탐색을 한다. 이때 6보다 작은 수는 1이고 1이 두 번째 원소
// 3. 첫 번째 원소와 두 번째 원소를 교체 한다. 10 <=> 1

// 4. 첫 번째 원소와 두 번째 원소 교체를 하고 이후 기준 값 피벗 6이 오른쪽을 탐색
// 5. 이때 퀵 정렬 순서 2와 3을 반복을 하고 배열에서 탐색하는 숫자가 엇갈리는 상황까지 반복

// 6. 첫 번째 원소(왼쪽에서 오른쪽 탐색)가 작동하고, 두 번째 원소(오른쪽에서 왼쪽으로 탐색)를 찾을 수 없을 때 엇갈렸다는 표현을 사용
// 7. 이 때 두 번째 원소(오른쪽에서 왼쪽으로 탐색)를 기준 값 피벗(Pivot)과 교체를 한다.
// 8. 이 때 배열의 첫 번째[0] 값을 기준 값 피벗(Pivot)으로 설정을 한다.

// 9. 1~8을 반복한다.

let num = 10;
let tempArr = [1, 10, 5, 3, 8, 9, 4, 2, 6];

const quickRe = (_data, _start, _end) => {
  // 매개변수로 _data, _start, _end를 받는다.
  // _data : [1, 10, 5, 3, 8, 9, 4, 2, 6] 배열과 배열의 요소
  // _start : 정렬을 수행하는 부분 집합의 첫 번째 요소 역할
  // _end : 정렬을 수행하는 부분 집합의 두 번째 요소 역할

  if (_start >= _end) {
    // _start >= _end : 원소가 1개인 경우
    return; // 원소가 1개인 경우 바로 리턴을 한다.
  }

  let key = _start; // 키는 [1, 10, 5,...] 배열의 첫 번째 인덱스를 기준 점 피벗을 설정 하는 역할
  let i = _start + 1; // 키 값을 피벗을 기준으로 왼쪽에서 오른쪽으로 탐색하여 나오는 값
  let j = _end; // 키 값을 피벗 기준으로 오른쪽에서 왼쪽을 탐색하여 나오는 값
  let temp; // _start 값 과 _end 값을 교체 해주는 역할로 임시 변수로 만들어 줌

  // 오름차순으로 형식
  //   while (_data[i] <= _data[key])
  //   while (_data[j] >= _data[key] && j > _start)

  // 내림차순으로 형식
  //   while (_data[i] >= _data[key])
  //   while (_data[j] <= _data[key] && j > _start)

  while (i <= j) {
    // i <= j 의미는 엇갈릴 때까지 반복하는 것으로 언제 엇갈릴지 확인을 판별 해준다. (작거나 같을 때)
    while (_data[i] <= _data[key]) {
      // 키 값보다 큰 값을 만날 때까지 반복
      i++;
    }
    while (_data[j] >= _data[key] && j > _start) {
      // 키 값보다 작은 값을 만날 때까지 반복
      j--;
    }
    if (i > j) {
      // 현재 엇갈린 상태면 이때 키 값과 교체를 한다.
      // 기준 값 피벗(Pivot)의 index 값이 변경 되는 시점에
      temp = _data[j];
      _data[j] = _data[key];
      _data[key] = temp;
      // 위 코드를 실행 시켜 스와핑을 한다.
    } else {
      // 만약 엇갈리지 않았다면 큰 값과 작은 값을 바꿔 줌
      temp = _data[j];
      _data[j] = _data[i];
      _data[j] = temp;
    }
  }

  // ---- 값이 엇갈려 if문을 실행하고 빠져 나왔을 때 작동
  quickRe(_data, _start, j - 1);
  // 왼쪽에서 오른쪽으로

  quickRe(_data, j + 1, _end);
  // 오른쪽에서 왼쪽으로
  // ---- 다시 설정 된 키 값 기준 값 피벗(Pivot)을 기준을 잡고 각각
  // quickSort(_data, _start, j - 1)와  quickSort(_data, j + 1, _end)가  돌아간다.
  // quickSort(_data, _start, j - 1)와  quickSort(_data, j + 1, _end)는 재귀함수
  // quickRe()함수 안에 quickRe()를 다시 호출
};

const quick = () => {
  quickRe(tempArr, 0, num - 1);
  for (let i = 0; i < num; i++) {
    console.log("퀵 정렬 완료:", tempArr[i]);
  }
};

// 퀵 정렬 시간 복잡도 = O(N * log^N)   log^N = 상수 개념으로 작은 수

// 2 ^ 10 = 1,000
// 2 ^ 20 = 1,000,000
// log2N에서 만약 N의 수가 1,000,000 이라고 가정 할 때  log2N의 수는 20이다.
// log2N = 20 = (1,000,000 * 0.00002)

// [1,2,3,4,5,6,7,8,9,10]

// 버블 정렬 = N^2 = N*N = 10*10 = 100연산

// 퀵 정렬 = N * log2N
// 1,2,3,4,5 = 5 * 5 = 25
// 6,7,8,9,10 = 5 * 5 = 25
// 25 + 25 = 50

// 퀵 정렬은 특정한 피벗 값을 이용해서 큰 값과 작은 값을 반복적으로 교체해준다.

// 퀵 정렬의 평균 시간 복잡도는 O(N*logN)

// 퀵 정렬 최악의 상황의 시간 복잡도는 O(N^2)

// 퀵 정렬의 최악의 상황은 이미 정렬 된 배열에 퀵 정렬을 사용 하는 것이다. 즉 분할 정복의 특징을 사용하지 못하는 것이다.
