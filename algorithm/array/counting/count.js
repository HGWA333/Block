// 계수 정렬 = "범위 조건이 있는 경우에 사용하면 굉장히 효율적으로 빠른 알고리즘이다." 배열의 요소가 중복 되어 있을 수록 빠르다.

// 범위 조건 = [1,2,3,4,3,2,5,3,2,1,3,2,3,1,2,3,5,6,2,1,3,1,1,1,3,1,1] 와 같이 수가 중복되어 있음

// 계수 정렬 시간 복잡도 O(N)

// 특징 = 계수 정렬은 단순하게 크기를 기준을 잡고 갯수를 센다. 그렇기 때문에 배열의 요소들의 위치를 바꿀 필요가 없다.
// 중복되는 수 + 중복되지 않는 수를 각각 배열로 만든다. 그리고 만들어진 배열에 적립하듯이 쌓는다.
// 계수 정렬은 데이터의 크기가 한정 되어있을 때 사용해야 한다.
// 예를 들어 [1,2,3,2,1,2,3,1,2,3,1,2,10000000]을 가진 데이터가 있을 경우
// 계수 정렬은 10000000까지 메모리 공간을 사용하기 때문에 비효율적이다.
// 그래서 데이터의 갭 차이가 나지 않을 때 사용해야한다.

// [1,2,3,4,3,2,5,3,2,1,3,2,3,1,2,3,5,6,2,1,3,1,1,1,3,1,1,]

// 0. 초기 상태  크기 = [] 형태
// 크기 = 1 , 크기 = 2 , 크기 = 3 , 크기 = 4 , 크기 = 5
//    0          0          0         0         0

// 1. 첫 번째 상태
// 크기 = 1 , 크기 = 2 , 크기 = 3 , 크기 = 4 , 크기 = 5
//    1          0          0         0         0

// 2. 두 번째 상태
// 크기 = 1 , 크기 = 2 , 크기 = 3 , 크기 = 4 , 크기 = 5
//    0          1          0         0         0

// 3. 세 번째 상태
// 크기 = 1 , 크기 = 2 , 크기 = 3 , 크기 = 4 , 크기 = 5
//    0          0          1         0         0

// 4. 네 번째 상태
// 크기 = 1 , 크기 = 2 , 크기 = 3 , 크기 = 4 , 크기 = 5
//    0          0          0         1         0

// 5. 다섯 번째 상태
// 크기 = 1 , 크기 = 2 , 크기 = 3 , 크기 = 4 , 크기 = 5
//    0          0          0         0         1

// 5. 완료 된  상태
// 크기 = 1 , 크기 = 2 , 크기 = 3 , 크기 = 4 , 크기 = 5
//    5          7          8         3         3

// 계수 정렬 완료 된 상태 = [1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4,5,5,5,5,5]

const CountingSort = () => {
  let temp;
  let Count = [1, 2, 3, 4, 5];
  let CountArr = [
    1, 3, 2, 3, 2, 1, 2, 3, 4, 5, 2, 3, 1, 3, 2, 1, 2, 3, 5, 4, 3, 4,
  ];

  for (let i = 0; i < 5; i++) {
    // CountArr의 배열 요소들을 Count배열 요소에 집어넣기 위한 과정
    Count[i] = 0;
    // count 배열의 index 요소를 0으로 초기화
  }
  for (let i = 0; i < 30; i++) {
    Count[CountArr[i] - 1]++;
    // [3[3,3,3,3], 4,[4,4,4,4], 1[1,1,1,], 2[2,2,2,], 5[5,5,5]]
  }
  for (let i = 0; i < 5; i++) {
    if (Count[i] != 0) {
      for (let j = 0; j < Count[i]; j) {
        // [1[],2[],3[],4[],5[]]
        console.log("계수 정렬 완료:", i + 1);
      }
    }
  }
  return 0;
};
