// 위상 정렬(Topology Sort)

// 위상 정렬은 순서가 정해져 있는 작업을 차례로 수행해야 할 때 그 순서를 결정해주기 위해 사용하는 알고리즘이다.
// 그래프의 흐름은 '조건'으로 해석할 수 있다. 즉 어떤 목적을 달성하기 위해서 목적을 위해 연관성이 있는 것을 만족시켜야 한다는 것이다.
// 예를들어 하나의 목적을 가는 방향에 여러 개의 순서가 정해져있을 경우 '조건'에 부합하는 일직선의 순서를 찾는 것이다.
// 즉 순차적으로 그래프가 형성 되어있을 때 일직선 상의 경로를 찾는 것이다.
// 또 하나의 답 말고 다른 경로의 답도 존재한다면 갈수 있다는 점이 장점이다.
// 하지만 위상 정렬은 DAG(Directed Acyclic Graph)에만 적용이 가능하다.
// DAG는 사이클이 발생하지 않는 방향 그래프를 의미한다. 다시말해 사이클이 발생할 경우 위상 정렬을 수행할 수 없다.

// 위상 정렬을 사용하기 위한 필수 사항
// 위상 정렬은 시작점이 존재 해야 한다. (사이클 발생시 시작점이 사라진다.)

// 위상 정렬 특징
// 위상 정렬은 두 가지 해결책을 낸다.
// 1. 현재 그래프는 위상 정렬이 가능한지?
// 2. 위상 정렬이 가능하다면 그 결과는 무엇인지?

// 이러한 위상 정렬을 수행하는 알고리즘으로는 크게 두 가지가 존재한다.
// 하나는 스택(Stack)을 이용하는 방식 또 다른 하나는 큐(Queue)를 이용한 방식

// 앞으로 위상 정렬 코드화는 큐를 기준으로 작성함

// 위상 정렬 알고리즘 순서
// 1. 진입차수가 0인 정점을 찾아 큐에 삽입한다. 진입차수가 0인 정점은 시작점(출발점)으로 잡을 수 있다.
// 2. 큐에서 원소를 꺼내 연결된 모든 간선을 제거한다.
// 3. 간선 제거 이후 진입차수가 0이 된 정점(노드)을 큐에 삽입한다.
// 4. 큐가 빌 때가지 2번 ~ 3번 과정을 반복한다. 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재하는 것이고, 모든 원소를 방문 했다면 큐에서 꺼낸 순서가 위상 정렬의 결과이다.

// 위상 정렬 작동 방식
// 첫 번째 행 [1,2,3,4,5,6,7]
// 두 번째 행 [0,1,1,1,1,2,1]

// 1회 작동)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 1 | 1 | 1 | 1 | 2 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//     1
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//
//    ----------------------------------

// 2회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 1 | 1 | 0 | 2 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//    2,5
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1
//    ----------------------------------

// 진입차수가 값이 있는 정점(노드)은 큐에 삽입이 된다.
// 이때 삽입 된 1이 큐 반출로 들어 갔을때 1에 연결 되어있던 간선들은 모두 끊어지게 된다.
// 그래서 큐에 삽입 된 2, 5의 간선이 0의 값으로 갱신한다.

// 3회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 1 | 1 | 0 | 2 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//     5
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2
//    ----------------------------------

// 4회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 0 | 1 | 0 | 2 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//     5, 3
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2
//    ----------------------------------
// 이때 큐로 반출 된 정점 2는 3에 연결 된 간선이 끊어지게 된다.
// 여기서 큐에 삽입이 되고 반출이 될 때 연결 된 간선이 끊어지게 되는 것을 알 수있다.

// 5회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 0 | 1 | 0 | 1 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//     3
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2, 5
//    ----------------------------------
// 이 지점에서는 새롭게 진입차수가 0인 것은 없는 상황이다.

// 6회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 0 | 0 | 0 | 1 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2, 5, 3
//    ----------------------------------
// 큐 반출로 들어간 3은 4와 연결된 간선을 끊게 된다. 4의 간선 갯수는 0 값으로 새로 갱신하게 된다.
// 이때 4는 진입차수가 0이 되어 4를 큐 삽입에 넣고 다시 반출을 하게 된다.

// 7회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 0 | 0 | 0 | 1 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//     4
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2, 5, 3
//    ----------------------------------

// 8회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 0 | 0 | 0 | 1 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2, 5, 3, 4
//    ----------------------------------

// 이후 진입차수가 0인 5를 큐에 삽입하고 6의 간선을 0의 값으로 갱신하게 된다.

// 9회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 0 | 0 | 0 | 1 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//    5
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2, 5, 3, 4
//    ----------------------------------

// 10회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 0 | 0 | 0 | 0 | 1 |

// Queue(큐 삽입)
//    ----------------------------------
//    6
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2, 5, 3, 4, 5
//    ----------------------------------

// 이후 6도 마찬가지로 진행이 되고 모든 진입차수는 0의 값으로 갱신을 한다.

// 11회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 0 | 0 | 0 | 0 | 0 |

// Queue(큐 삽입)
//    ----------------------------------
//    7
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2, 5, 3, 4, 5, 6
//    ----------------------------------

// 12회 동작)
// 정정점점  1 | 2 | 3 | 4 | 5 | 6 | 7 |
// 진입차수  0 | 0 | 0 | 0 | 0 | 0 | 0 |

// Queue(큐 삽입)
//    ----------------------------------
//
//    ----------------------------------

// Queue(큐 반출)
//    ----------------------------------
//     1, 2, 5, 3, 4, 5, 6, 7
//    ----------------------------------

// 이때 큐에서 꺼낸 1, 2, 5, 3, 4, 6, 7이 한번도 큐가 빈적이 없기 때문에 사이클이 발생하지 않았다는 것을 알 수 있다.

// 위상 정렬 알고리즘 작동 결과  1 -> 2 -> 5 -> 3 -> 4 -> 6 -> 7

// 위상 정렬 코드화

function topologySort() {
  let reult = [max];
  let queue = q;
  // 진입 차수가 0인 노드를 큐에 삽입
  for (let i = 1; i <= n; i++) {
    if (inDegree[i] == 0) q.push(i);
  }
  // 위상 정렬이 완전히 수행되려면 정확히 N개의 노드를 방문
  for (let i = 1; i <= n; i++) {
    // n개를 방문하기 전에 큐가 빈다면 사이클이 발생했다는 의미
    if (q.empty()) {
      console.log("사이클이 발생하지 않았음");
      return;
    }
    let x = q.front();
    q.pop();
    reult[i] = x;
    for (let i = 0; i < a[x].size(); i++) {
      let y = a[x][i];
      // 진입차수가 재롭게 0이 된 정점(노드)에 큐를 사입한다.
      if (--inDegree[y] == 0) {
        q.push(y);
      }
    }
    for (let i = 1; i <= n; i++) {
      console.log("위상 정렬 완료", reult[i]);
    }
  }
}
