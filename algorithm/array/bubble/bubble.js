// 버블 정렬 = 옆에 있는 값과 비교하여 더 작은 값을 앞으로 보낸다.

// 버블 정렬 시간 복잡도 O(N^2)

// 특징 = 버블정렬은 구현하기 쉽지만 효율성이 가장 떨어지는 비효율성 정렬이다.

// 1번 부터 10번째까지 선택 후 교체
// 1번 부터 9번째까지 선택 후 교체
// 1번 부터 8번째까지 선택 후 교체
// ... 방식으로 뒤에있는 원소가 하나씩 줄어는 방식이다. * 당장 옆에 있는 것과 비교하여 교체

// 버블정렬에는 3가지 변수 i, j, temp가 사용이 된다.

const buble = () => {
  let i; // 배열의 원소를 반복적으로 탐색하기 위한 용도 1
  let j; // 배열의 원소를 반복적으로 탐색하기 위한 용도 2
  let temp; // 특정한 두 숫자를 서로 바꾸기 위해 만든 임시적인 변수

  let tempArr = [1, 3, 5, 7, 9, 10, 2, 4, 6, 8]; // 가장 작은 숫자를 앞으로 정렬 하기 위한 목적물

  for (let i = 0; i < 10; i++) {
    for (j = 0; j < 9 - i; j++) {
      // j = 0; j < 9 - i; j++의 의미는 뒤에서 부터 집합의 크기를 1씩 줄이는 형태
      if (tempArr[j] > tempArr[j + 1]) {
        temp = tempArr[j];
        tempArr[j] = tempArr[j + 1];
        tempArr[j + 1] = temp;
      }
    }
  }
  for (i = 0; i < 10; i++) {
    console.log("버블 정렬 완료:", tempArr[i]);
  } // 정렬이 완료된 후 결과를 확인하기 위해 console.log로 확인
  return 0;
};

// 버블 정렬은 선택 정렬과 시간 복잡도가 같지만 비효율적인 이유

// 선택 정렬은 가장 작은 것을 하나 골라 마지막에만 교체를 한다.

// 하지만 버블 정렬은 배열의 맨 앞자리를 기준점으로 잡고 배열의 요소를 모두 연산을 하여 교체를 하기 때문이다. 그래서 비효율적임

// 위와 같은 형태의 시간 복잡도 O(N^2)로 버블 정렬의 시간 복잡도 O(N^2)와 같다.

// 하나의 배열에 10개의 원소가 담겨져 있다고 가정을 하면 [1,2,3,4,5,6,7,8,9,10]

// 10 + 9 + 8 + .. + 1 는 등차수열로  10 * (10 + 1) / 2 = 55 즉 55를 연산을 한다.

// 만약 10,000개의 데이터가 있다면 10,000 * 10,000으로 100,000,000 1억번 정도 연산을 해야 한다.

// 10 * (10 + 1) / 2을 수식으로 표현 하면 N * (N + 1) / 2

// N * (N + 1) / 2 = N * N 과 같음

// O(N * N)으로 축약해서 사용하고 이걸 비고표기법이라고 함
